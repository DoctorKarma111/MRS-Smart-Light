"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AccountDeactivationReason: () => AccountDeactivationReason,
  ApiEndpoint: () => ApiEndpoint,
  AuthEndpoint: () => AuthEndpoint,
  CancellationReason: () => CancellationReason,
  ChatMessageEndpoint: () => ChatMessageEndpoint,
  Class: () => Class,
  ClientEndpoint: () => ClientEndpoint,
  CodeEndpoint: () => CodeEndpoint,
  CodeType: () => CodeType,
  EmergencyEndpoint: () => EmergencyEndpoint,
  Level: () => Level,
  LocationType: () => LocationType,
  MedrunnerApiClient: () => MedrunnerApiClient,
  MissionServices: () => MissionServices,
  MissionStatus: () => MissionStatus,
  OrgSettingsEndpoint: () => OrgSettingsEndpoint,
  Origin: () => Origin,
  PersonType: () => PersonType,
  ResponseRating: () => ResponseRating,
  ServiceStatus: () => ServiceStatus,
  StaffEndpoint: () => StaffEndpoint,
  SubmissionSource: () => SubmissionSource,
  ThreatLevel: () => ThreatLevel,
  TokenManager: () => TokenManager,
  UserRoles: () => UserRoles,
  WebsocketEndpoint: () => WebsocketEndpoint
});
module.exports = __toCommonJS(src_exports);

// src/api/endpoints/ApiEndpoint.ts
var import_axios = __toESM(require("axios"));
var ApiEndpoint = class {
  constructor(baseUrl, tokenManager, log, headerProvider) {
    this.tokenManager = tokenManager;
    this.log = log;
    this.headerProvider = headerProvider;
    this.baseUrl = baseUrl ?? "https://api.medrunner.space";
  }
  static {
    __name(this, "ApiEndpoint");
  }
  baseUrl;
  endpointUrl() {
    return `${this.baseUrl}/${this.endpoint()}`;
  }
  async headersForRequest(noAuthentication) {
    const config = {
      baseURL: this.baseUrl,
      headers: {}
    };
    if (config.headers !== void 0) {
      if (!noAuthentication) {
        const accessToken = await this.tokenManager.getAccessToken("API makeRequest");
        if (accessToken !== void 0) {
          config.headers.Authorization = `Bearer ${accessToken}`;
        }
      }
      if (this.headerProvider !== void 0) {
        for (const header of Object.entries(await this.headerProvider())) {
          config.headers[header[0]] = header[1];
        }
      }
    }
    return config;
  }
  async getRequest(endpoint, queryParams, noAuthentication) {
    return await this.makeRequestWithoutBody(endpoint, "GET", import_axios.default.get, queryParams, noAuthentication);
  }
  async postRequest(endpoint, data, noAuthentication) {
    return await this.makeRequestWithBody(endpoint, "POST", import_axios.default.post, data, noAuthentication);
  }
  async putRequest(endpoint, data, noAuthentication) {
    return await this.makeRequestWithBody(endpoint, "PUT", import_axios.default.put, data, noAuthentication);
  }
  async patchRequest(endpoint, data, noAuthentication) {
    return await this.makeRequestWithBody(endpoint, "PATCH", import_axios.default.patch, data, noAuthentication);
  }
  async deleteRequest(endpoint, queryParams, noAuthentication) {
    return await this.makeRequestWithoutBody(endpoint, "DELETE", import_axios.default.delete, queryParams, noAuthentication);
  }
  async makeRequestWithBody(endpoint, requestType, axiosRequest, data, noAuthentication) {
    const wrappedRequest = /* @__PURE__ */ __name(async (requestUrl, config) => await axiosRequest(requestUrl, data, config), "wrappedRequest");
    return await this.makeRequest(endpoint, requestType, wrappedRequest, void 0, noAuthentication);
  }
  async makeRequestWithoutBody(endpoint, requestType, axiosRequest, queryParams, noAuthentication) {
    const wrappedRequest = /* @__PURE__ */ __name(async (requestUrl, config) => await axiosRequest(requestUrl, config), "wrappedRequest");
    return await this.makeRequest(endpoint, requestType, wrappedRequest, queryParams, noAuthentication);
  }
  buildUrl(endpoint) {
    const baseUrl = this.endpointUrl();
    if (baseUrl.endsWith("/")) {
      if (endpoint.startsWith("/")) {
        return `${baseUrl}${endpoint.substring(1)}`;
      }
      return `${baseUrl}${endpoint}`;
    }
    if (endpoint.startsWith("/")) {
      return `${baseUrl}${endpoint}`;
    }
    return `${baseUrl}/${endpoint}`;
  }
  async makeRequest(endpoint, requestType, request, queryParams, noAuthentication = false) {
    const requestUrl = this.buildUrl(endpoint);
    this.log?.debug(`sending ${requestType} request to ${requestUrl}`);
    try {
      const config = await this.headersForRequest(noAuthentication);
      if (queryParams !== void 0) {
        config.params = queryParams;
      }
      const result = await request(requestUrl, config);
      return {
        success: true,
        data: result.data
      };
    } catch (e) {
      this.log?.warn(`Error for ${requestType} request to ${requestUrl}: ${e}`);
      return {
        success: false,
        errorMessage: e instanceof import_axios.AxiosError ? e.response?.data : void 0,
        statusCode: e instanceof import_axios.AxiosError ? e.response?.status : void 0
      };
    }
  }
};

// src/api/endpoints/auth/AuthEndpoint.ts
var AuthEndpoint = class extends ApiEndpoint {
  static {
    __name(this, "AuthEndpoint");
  }
  constructor(baseUrl, tokenManager, log, headerProvider) {
    super(baseUrl, tokenManager, log, headerProvider);
  }
  endpoint() {
    return "auth";
  }
  /**
   * Invalidate a refresh token.
   *
   * @param oldToken - Token to be invalidated
   *
   * @virtual
   * */
  async signOut(oldToken) {
    return await this.postRequest("/signOut", oldToken);
  }
  /**
   * Gets all api tokens for the user.
   *
   * */
  async getApiTokens() {
    return await this.getRequest(`/apiTokens`);
  }
  /**
   * Creates an api token.
   *
   * @param newToken - Emergency details for the new emergency
   * @returns The newly-created api token
   *
   * @virtual
   * */
  async createApiToken(newToken) {
    return await this.postRequest("/apiTokens", {
      name: newToken.name,
      expirationDate: newToken.expirationDate?.toISOString()
    });
  }
  /**
   * Delete an api token.
   *
   * @param id - The id of the api token to delete
   *
   * */
  async deleteApiToken(id) {
    return await this.deleteRequest(`/apiTokens/${id}`);
  }
};

// src/api/endpoints/auth/TokenManager.ts
var TokenManager = class extends ApiEndpoint {
  constructor(config, refreshCallback, log, headerProvider) {
    super(config.baseUrl, null, log, headerProvider);
    this.refreshCallback = refreshCallback;
    this.accessToken = config.accessToken;
    this.refreshToken = config.refreshToken;
  }
  static {
    __name(this, "TokenManager");
  }
  accessToken;
  refreshToken;
  accessTokenExpiration;
  refreshTokenExpiration;
  tokenFetchPromise;
  endpoint() {
    return "auth";
  }
  async getAccessToken(source = "unknown") {
    this.log?.debug(`getAccessToken: New token requested from ${source}`);
    if (this.accessToken !== void 0 && this.accessTokenExpiration !== void 0) {
      const exp = Math.trunc(new Date(this.accessTokenExpiration).getTime() / 1e3);
      const now = Math.trunc(Date.now() / 1e3);
      if (exp - 300 > now) {
        this.log?.debug(`getAccessToken: ${source} => Token valid and simply returned`);
        return this.accessToken;
      }
    }
    if (this.refreshToken === void 0) {
      this.log?.debug(`getAccessToken: ${source} => Missing refresh token, returning stored access token`);
      return this.accessToken;
    }
    if (!this.tokenFetchPromise) {
      this.log?.debug(`getAccessToken: ${source} => No current token fetch, starting new fetch`);
      this.tokenFetchPromise = this.fetchToken(this.refreshToken, source);
    }
    try {
      this.log?.debug(`getAccessToken: ${source} => Waiting for token fetch to complete`);
      const tokens = await this.tokenFetchPromise;
      this.log?.debug(`getAccessToken: ${source} => Setting new tokens in memory`);
      this.accessToken = tokens.accessToken;
      this.refreshToken = tokens.refreshToken;
      this.accessTokenExpiration = tokens.accessTokenExpiration;
      if (tokens.refreshTokenExpiration) this.refreshTokenExpiration = tokens.refreshTokenExpiration;
      if (this.refreshCallback !== void 0) {
        this.log?.debug(`getAccessToken: ${source} => Calling refresh callback with new tokens`);
        await this.refreshCallback(tokens);
      }
    } finally {
      this.tokenFetchPromise = void 0;
    }
    this.log?.debug(`getAccessToken: ${source} => Returning new access token`);
    return this.accessToken;
  }
  async fetchToken(refreshToken, source = "unknown") {
    this.log?.debug(`getAccessToken: ${source} => Fetching new tokens`);
    const result = await this.postRequest("/exchange", { refreshToken }, true);
    if (!result.success || result.data === void 0) {
      throw Error(result.statusCode?.toString());
    }
    this.log?.debug(`getAccessToken: ${source} => Successfully fetched new tokens`);
    return result.data;
  }
};

// src/api/endpoints/chatMessage/ChatMessageEndpoint.ts
var ChatMessageEndpoint = class extends ApiEndpoint {
  static {
    __name(this, "ChatMessageEndpoint");
  }
  constructor(baseUrl, tokenManager, log, headerProvider) {
    super(baseUrl, tokenManager, log, headerProvider);
  }
  endpoint() {
    return "chatMessage";
  }
  /**
   * Gets the specified amount of chat messages for a given emergency.
   *
   * @param emergencyId - The emergency for which to fetch the chat history
   * @param limit - The number of emergencies to get
   * @param paginationToken - The number to use for pagination
   * */
  async getHistory(emergencyId, limit, paginationToken) {
    return await this.getRequest(`/${emergencyId}`, { limit, paginationToken });
  }
  /**
   * Sends a new chat message
   *
   * @param message - The message to send
   * @returns The newly-created chat message
   *
   * */
  async sendMessage(message) {
    return await this.postRequest("", message);
  }
};

// src/api/endpoints/client/ClientEndpoint.ts
var ClientEndpoint = class extends ApiEndpoint {
  static {
    __name(this, "ClientEndpoint");
  }
  constructor(baseUrl, tokenManager, log, headerProvider) {
    super(baseUrl, tokenManager, log, headerProvider);
  }
  endpoint() {
    return "client";
  }
  /**
   * Gets the current client.
   * */
  async get() {
    return await this.getRequest("");
  }
  /**
   * Gets the specified amount of emergencies the client has created.
   * @param limit - The number of emergencies to get
   * @param paginationToken - The number to use for pagination
   * */
  async getHistory(limit, paginationToken) {
    return await this.getRequest("/history", { limit, paginationToken });
  }
  /**
   * Gets the blocklist status of the current client.
   * */
  async getBlockedStatus() {
    return await this.getRequest("/blocked");
  }
  /**
   * Links the current user to a rsiHandle.
   *
   * @param rsiHandle - The RSI handle of the client
   *
   * */
  async linkClient(rsiHandle) {
    return await this.postRequest("/link", { rsiHandle });
  }
  /**
   * Updates the settings of the current user for the Client Portal.
   *
   * @deprecated Use {@link setUserSettings} instead
   * @param settings - The stringfied new object settings that will replace the old one
   * @returns The updated settings object
   *
   * */
  async setSettings(settings) {
    return await this.patchRequest("/settings/clientPortal", settings);
  }
  /**
   * Updates the settings of the current user for the Client Portal.
   *
   * @param settings - The object settings to add or update
   *
   * */
  async setUserSettings(settings) {
    return await this.putRequest("/settings/clientPortal", { settingsBlob: settings });
  }
  /**
   * Deactivate the current client.
   * */
  async deactivate() {
    return await this.deleteRequest("");
  }
};

// src/api/endpoints/code/CodeEndpoint.ts
var CodeEndpoint = class extends ApiEndpoint {
  static {
    __name(this, "CodeEndpoint");
  }
  constructor(baseUrl, tokenManager, log, headerProvider) {
    super(baseUrl, tokenManager, log, headerProvider);
  }
  endpoint() {
    return "code";
  }
  /**
   * Redeems the specified promotional code for the current user
   *
   * @param code - The code to redeem.
   * */
  async redeem(code) {
    return await this.postRequest(`/redeem/${code}`);
  }
};

// src/api/endpoints/emergency/EmergencyEndpoint.ts
var EmergencyEndpoint = class extends ApiEndpoint {
  static {
    __name(this, "EmergencyEndpoint");
  }
  constructor(baseUrl, tokenManager, log, headerProvider) {
    super(baseUrl, tokenManager, log, headerProvider);
  }
  endpoint() {
    return "emergency";
  }
  /**
   * Gets an emergency by id.
   *
   * @param id - The id of the emergency to retrieve
   * */
  async getEmergency(id) {
    return await this.getRequest(`/${id}`);
  }
  /**
   * Bulk fetches emergencies by id.
   *
   * @param ids - a list of emergencies to retrieve
   * */
  async getEmergencies(ids) {
    return await this.getRequest(`/bulk?id=${ids.join("&id=")}`);
  }
  /**
   * Creates a new emergency.
   *
   * @param newEmergency - Emergency details for the new emergency
   * @returns The newly-created emergency
   *
   * @virtual
   * */
  async createEmergency(newEmergency) {
    return await this.postRequest("", newEmergency);
  }
  /**
   * Cancels an existing emergency.
   *
   * @remarks
   * Emergency must still be in the {@link MissionStatus.RECEIVED} state in order to be canceled.
   *
   * @param id - The id of the emergency to cancel
   * @param reason - The reason the emergency was canceled
   * */
  async cancelEmergencyWithReason(id, reason) {
    return await this.postRequest(`/${id}/cancelWithReason`, {
      reason
    });
  }
  /**
   * Allows the client to rate their emergency.
   *
   * @param id - The id of the emergency to rate
   * @param rating - The rating to give the services provided
   * @param remarks - Additional remarks provided by the client
   *
   * @internal
   * */
  async rateServices(id, rating, remarks) {
    return await this.postRequest(`/${id}/rate/`, {
      rating,
      remarks
    });
  }
  /**
   * Fetches additional details about the responding team for an alert.
   *
   * @param id - The id of the emergency to get team details about
   * */
  async teamDetails(id) {
    return await this.getRequest(`/${id}/teamDetails`);
  }
  /**
   * Gets a tree of valid locations from which an emergency may be submitted.
   * */
  async emergencyLocations() {
    return await this.getRequest("/meta/locations");
  }
};

// src/api/endpoints/orgSettings/OrgSettingsEndpoint.ts
var OrgSettingsEndpoint = class extends ApiEndpoint {
  static {
    __name(this, "OrgSettingsEndpoint");
  }
  constructor(baseUrl, tokenManager, log, headerProvider) {
    super(baseUrl, tokenManager, log, headerProvider);
  }
  endpoint() {
    return "orgsettings";
  }
  /**
   * Get the public org settings.
   *
   * */
  async getPublicSettings() {
    return await this.getRequest(`/public`);
  }
};

// src/api/endpoints/staff/StaffEndpoint.ts
var StaffEndpoint = class extends ApiEndpoint {
  static {
    __name(this, "StaffEndpoint");
  }
  constructor(baseUrl, tokenManager, log, headerProvider) {
    super(baseUrl, tokenManager, log, headerProvider);
  }
  endpoint() {
    return "staff";
  }
  /**
   * Gets detailed information about medals.
   * */
  async medalsInformation() {
    return await this.getRequest("/meta/medals");
  }
};

// src/api/endpoints/websocket/WebsocketManager.ts
var import_signalr = require("@microsoft/signalr");
var WSLogger = class {
  constructor(logger) {
    this.logger = logger;
  }
  static {
    __name(this, "WSLogger");
  }
  log(logLevel, message) {
    switch (logLevel) {
      case import_signalr.LogLevel.Trace:
        this.logger?.trace(`Websocket: ${message}`);
        break;
      case import_signalr.LogLevel.Information:
        this.logger?.info(`Websocket: ${message}`);
        break;
      case import_signalr.LogLevel.Warning:
        this.logger?.warn(`Websocket: ${message}`);
        break;
      case (import_signalr.LogLevel.Error || import_signalr.LogLevel.Critical):
        this.logger?.error(`Websocket: ${message}`);
        break;
      case import_signalr.LogLevel.Debug:
        this.logger?.debug(`Websocket: ${message}`);
        break;
    }
  }
};
var WebsocketManager = class {
  constructor(baseUrl, tokenManager, logger) {
    this.baseUrl = baseUrl;
    this.tokenManager = tokenManager;
    this.logger = logger;
  }
  static {
    __name(this, "WebsocketManager");
  }
  tokenManager;
  logger;
  async establishConnection() {
    return new import_signalr.HubConnectionBuilder().withAutomaticReconnect({
      nextRetryDelayInMilliseconds: /* @__PURE__ */ __name((retryContext) => retryContext.previousRetryCount > 5 ? null : 2e3, "nextRetryDelayInMilliseconds")
    }).withUrl(`${this.baseUrl}/hub/emergency`, {
      accessTokenFactory: /* @__PURE__ */ __name(async () => await this.tokenManager.getAccessToken("WS accessTokenFactory") ?? "", "accessTokenFactory")
    }).configureLogging(new WSLogger(this.logger)).build();
  }
};

// src/api/endpoints/websocket/WebsocketEndpoint.ts
var WebsocketEndpoint = class extends ApiEndpoint {
  static {
    __name(this, "WebsocketEndpoint");
  }
  constructor(baseUrl, tokenManager, log, headerProvider) {
    super(baseUrl, tokenManager, log, headerProvider);
  }
  websocketManager = new WebsocketManager(this.baseUrl, this.tokenManager, this.log);
  endpoint() {
    return "websocket";
  }
  /**
   * Gets realtime updates.
   *
   * */
  async initialize() {
    if (this.websocketManager === void 0) {
      throw new Error("WebsocketManager is undefined");
    }
    return await this.websocketManager.establishConnection();
  }
};

// src/api/MedrunnerApiClient.ts
var MedrunnerApiClient = class _MedrunnerApiClient {
  constructor(emergency, client, staff, orgSettings, chatMessage, code, auth, websocket) {
    this.emergency = emergency;
    this.client = client;
    this.staff = staff;
    this.orgSettings = orgSettings;
    this.chatMessage = chatMessage;
    this.code = code;
    this.auth = auth;
    this.websocket = websocket;
  }
  static {
    __name(this, "MedrunnerApiClient");
  }
  /**
   * Constructs a new API client.
   *
   * @param config - The API configuration
   * @param refreshCallback - a callback function called whenever a refresh token exchange is performed
   * @param log - A logger which logs request details
   * */
  static buildClient(config, refreshCallback, log) {
    const tokenManager = new TokenManager(config, refreshCallback, log);
    return new _MedrunnerApiClient(
      new EmergencyEndpoint(config.baseUrl, tokenManager, log),
      new ClientEndpoint(config.baseUrl, tokenManager, log),
      new StaffEndpoint(config.baseUrl, tokenManager, log),
      new OrgSettingsEndpoint(config.baseUrl, tokenManager, log),
      new ChatMessageEndpoint(config.baseUrl, tokenManager, log),
      new CodeEndpoint(config.baseUrl, tokenManager, log),
      new AuthEndpoint(config.baseUrl, tokenManager, log),
      new WebsocketEndpoint(config.baseUrl, tokenManager, log)
    );
  }
};

// src/api/endpoints/emergency/response/LocationDetail.ts
var LocationType = /* @__PURE__ */ ((LocationType2) => {
  LocationType2[LocationType2["UNKNOWN"] = 0] = "UNKNOWN";
  LocationType2[LocationType2["SYSTEM"] = 1] = "SYSTEM";
  LocationType2[LocationType2["PLANET"] = 2] = "PLANET";
  LocationType2[LocationType2["MOON"] = 3] = "MOON";
  return LocationType2;
})(LocationType || {});

// src/models/CancellationReason.ts
var CancellationReason = /* @__PURE__ */ ((CancellationReason2) => {
  CancellationReason2[CancellationReason2["NONE"] = 0] = "NONE";
  CancellationReason2[CancellationReason2["OTHER"] = 1] = "OTHER";
  CancellationReason2[CancellationReason2["SUCCUMBED_TO_WOUNDS"] = 2] = "SUCCUMBED_TO_WOUNDS";
  CancellationReason2[CancellationReason2["SERVER_ERROR"] = 3] = "SERVER_ERROR";
  CancellationReason2[CancellationReason2["RESPAWNED"] = 4] = "RESPAWNED";
  CancellationReason2[CancellationReason2["RESCUED"] = 5] = "RESCUED";
  return CancellationReason2;
})(CancellationReason || {});

// src/models/Class.ts
var Class = /* @__PURE__ */ ((Class2) => {
  Class2[Class2["NONE"] = 0] = "NONE";
  Class2[Class2["MEDIC"] = 1] = "MEDIC";
  Class2[Class2["SECURITY"] = 2] = "SECURITY";
  Class2[Class2["PILOT"] = 3] = "PILOT";
  Class2[Class2["LEAD"] = 4] = "LEAD";
  Class2[Class2["DISPATCH"] = 5] = "DISPATCH";
  Class2[Class2["DISPATCH_LEAD"] = 6] = "DISPATCH_LEAD";
  Class2[Class2["DISPATCH_TRAINEE"] = 7] = "DISPATCH_TRAINEE";
  Class2[Class2["DISPATCH_OBSERVER"] = 8] = "DISPATCH_OBSERVER";
  Class2[Class2["QRF"] = 9] = "QRF";
  Class2[Class2["LOGISTICS"] = 10] = "LOGISTICS";
  return Class2;
})(Class || {});

// src/models/Emergency.ts
var MissionServices = /* @__PURE__ */ ((MissionServices2) => {
  MissionServices2[MissionServices2["NONE"] = 0] = "NONE";
  MissionServices2[MissionServices2["PVE"] = 1] = "PVE";
  MissionServices2[MissionServices2["PVP"] = 2] = "PVP";
  MissionServices2[MissionServices2["REVIVED_HEALED"] = 4] = "REVIVED_HEALED";
  MissionServices2[MissionServices2["HEALED_IN_SHIP"] = 8] = "HEALED_IN_SHIP";
  MissionServices2[MissionServices2["EXTRACT_SAFE_ZONE"] = 16] = "EXTRACT_SAFE_ZONE";
  return MissionServices2;
})(MissionServices || {});
var Origin = /* @__PURE__ */ ((Origin2) => {
  Origin2[Origin2["UNKNOWN"] = 0] = "UNKNOWN";
  Origin2[Origin2["REPORT"] = 1] = "REPORT";
  Origin2[Origin2["BEACON"] = 2] = "BEACON";
  Origin2[Origin2["EVALUATION"] = 3] = "EVALUATION";
  return Origin2;
})(Origin || {});
var SubmissionSource = /* @__PURE__ */ ((SubmissionSource2) => {
  SubmissionSource2[SubmissionSource2["UNKNOWN"] = 0] = "UNKNOWN";
  SubmissionSource2[SubmissionSource2["API"] = 1] = "API";
  SubmissionSource2[SubmissionSource2["BOT"] = 2] = "BOT";
  return SubmissionSource2;
})(SubmissionSource || {});

// src/models/MissionStatus.ts
var MissionStatus = /* @__PURE__ */ ((MissionStatus2) => {
  MissionStatus2[MissionStatus2["CREATED"] = 0] = "CREATED";
  MissionStatus2[MissionStatus2["RECEIVED"] = 1] = "RECEIVED";
  MissionStatus2[MissionStatus2["IN_PROGRESS"] = 2] = "IN_PROGRESS";
  MissionStatus2[MissionStatus2["SUCCESS"] = 3] = "SUCCESS";
  MissionStatus2[MissionStatus2["FAILED"] = 4] = "FAILED";
  MissionStatus2[MissionStatus2["NO_CONTACT"] = 5] = "NO_CONTACT";
  MissionStatus2[MissionStatus2["CANCELED"] = 6] = "CANCELED";
  MissionStatus2[MissionStatus2["REFUSED"] = 7] = "REFUSED";
  MissionStatus2[MissionStatus2["ABORTED"] = 8] = "ABORTED";
  MissionStatus2[MissionStatus2["SERVER_ERROR"] = 9] = "SERVER_ERROR";
  return MissionStatus2;
})(MissionStatus || {});

// src/models/Person.ts
var UserRoles = /* @__PURE__ */ ((UserRoles2) => {
  UserRoles2[UserRoles2["CLIENT"] = 1] = "CLIENT";
  UserRoles2[UserRoles2["STAFF"] = 2] = "STAFF";
  UserRoles2[UserRoles2["DEVELOPER"] = 524288] = "DEVELOPER";
  UserRoles2[UserRoles2["BOT"] = 1048576] = "BOT";
  return UserRoles2;
})(UserRoles || {});
var PersonType = /* @__PURE__ */ ((PersonType2) => {
  PersonType2[PersonType2["CLIENT"] = 0] = "CLIENT";
  PersonType2[PersonType2["STAFF"] = 1] = "STAFF";
  PersonType2[PersonType2["BOT"] = 2] = "BOT";
  return PersonType2;
})(PersonType || {});
var AccountDeactivationReason = /* @__PURE__ */ ((AccountDeactivationReason2) => {
  AccountDeactivationReason2[AccountDeactivationReason2["NONE"] = 0] = "NONE";
  AccountDeactivationReason2[AccountDeactivationReason2["CLIENT_DRIVEN_DELETION"] = 1] = "CLIENT_DRIVEN_DELETION";
  AccountDeactivationReason2[AccountDeactivationReason2["TERMINATED"] = 2] = "TERMINATED";
  AccountDeactivationReason2[AccountDeactivationReason2["BLOCKED"] = 3] = "BLOCKED";
  return AccountDeactivationReason2;
})(AccountDeactivationReason || {});
var CodeType = /* @__PURE__ */ ((CodeType2) => {
  CodeType2[CodeType2["Unknown"] = 0] = "Unknown";
  CodeType2[CodeType2["CitizenCon2954"] = 1] = "CitizenCon2954";
  return CodeType2;
})(CodeType || {});

// src/models/Level.ts
var Level = /* @__PURE__ */ ((Level2) => {
  Level2[Level2["None"] = 0] = "None";
  Level2[Level2["Tier1Section1"] = 101] = "Tier1Section1";
  Level2[Level2["Tier1Section2"] = 102] = "Tier1Section2";
  Level2[Level2["Tier1Section3"] = 103] = "Tier1Section3";
  Level2[Level2["Tier2Section1"] = 201] = "Tier2Section1";
  Level2[Level2["Tier2Section2"] = 202] = "Tier2Section2";
  Level2[Level2["Tier2Section3"] = 203] = "Tier2Section3";
  Level2[Level2["Tier3Section1"] = 301] = "Tier3Section1";
  Level2[Level2["Tier3Section2"] = 302] = "Tier3Section2";
  Level2[Level2["Tier3Section3"] = 303] = "Tier3Section3";
  Level2[Level2["Tier4Section1"] = 401] = "Tier4Section1";
  Level2[Level2["Tier4Section2"] = 402] = "Tier4Section2";
  Level2[Level2["Tier4Section3"] = 403] = "Tier4Section3";
  Level2[Level2["Tier5Section1"] = 501] = "Tier5Section1";
  Level2[Level2["Tier5Section2"] = 502] = "Tier5Section2";
  Level2[Level2["Tier5Section3"] = 503] = "Tier5Section3";
  Level2[Level2["Tier6Section1"] = 601] = "Tier6Section1";
  Level2[Level2["Tier6Section2"] = 602] = "Tier6Section2";
  Level2[Level2["Tier6Section3"] = 603] = "Tier6Section3";
  Level2[Level2["Tier7Section1"] = 701] = "Tier7Section1";
  Level2[Level2["Tier7Section2"] = 702] = "Tier7Section2";
  Level2[Level2["Tier7Section3"] = 703] = "Tier7Section3";
  Level2[Level2["Tier8Section1"] = 801] = "Tier8Section1";
  Level2[Level2["Tier8Section2"] = 802] = "Tier8Section2";
  Level2[Level2["Tier8Section3"] = 803] = "Tier8Section3";
  Level2[Level2["Tier9Section1"] = 901] = "Tier9Section1";
  Level2[Level2["Tier9Section2"] = 902] = "Tier9Section2";
  Level2[Level2["Tier9Section3"] = 903] = "Tier9Section3";
  Level2[Level2["Tier10Section1"] = 1001] = "Tier10Section1";
  Level2[Level2["Tier10Section2"] = 1002] = "Tier10Section2";
  Level2[Level2["Tier10Section3"] = 1003] = "Tier10Section3";
  return Level2;
})(Level || {});

// src/models/ResponseRating.ts
var ResponseRating = /* @__PURE__ */ ((ResponseRating2) => {
  ResponseRating2[ResponseRating2["NONE"] = 0] = "NONE";
  ResponseRating2[ResponseRating2["GOOD"] = 1] = "GOOD";
  ResponseRating2[ResponseRating2["BAD"] = 2] = "BAD";
  return ResponseRating2;
})(ResponseRating || {});

// src/models/ThreatLevel.ts
var ThreatLevel = /* @__PURE__ */ ((ThreatLevel2) => {
  ThreatLevel2[ThreatLevel2["UNKNOWN"] = 0] = "UNKNOWN";
  ThreatLevel2[ThreatLevel2["LOW"] = 1] = "LOW";
  ThreatLevel2[ThreatLevel2["MEDIUM"] = 2] = "MEDIUM";
  ThreatLevel2[ThreatLevel2["HIGH"] = 3] = "HIGH";
  return ThreatLevel2;
})(ThreatLevel || {});

// src/models/PublicOrgSettings.ts
var ServiceStatus = /* @__PURE__ */ ((ServiceStatus2) => {
  ServiceStatus2[ServiceStatus2["UNKNOWN"] = 0] = "UNKNOWN";
  ServiceStatus2[ServiceStatus2["HEALTHY"] = 1] = "HEALTHY";
  ServiceStatus2[ServiceStatus2["SLIGHTLY_DEGRADED"] = 2] = "SLIGHTLY_DEGRADED";
  ServiceStatus2[ServiceStatus2["HEAVILY_DEGRADED"] = 3] = "HEAVILY_DEGRADED";
  ServiceStatus2[ServiceStatus2["OFFLINE"] = 4] = "OFFLINE";
  return ServiceStatus2;
})(ServiceStatus || {});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AccountDeactivationReason,
  ApiEndpoint,
  AuthEndpoint,
  CancellationReason,
  ChatMessageEndpoint,
  Class,
  ClientEndpoint,
  CodeEndpoint,
  CodeType,
  EmergencyEndpoint,
  Level,
  LocationType,
  MedrunnerApiClient,
  MissionServices,
  MissionStatus,
  OrgSettingsEndpoint,
  Origin,
  PersonType,
  ResponseRating,
  ServiceStatus,
  StaffEndpoint,
  SubmissionSource,
  ThreatLevel,
  TokenManager,
  UserRoles,
  WebsocketEndpoint
});
//# sourceMappingURL=index.js.map