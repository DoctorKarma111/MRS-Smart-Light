import { Logger } from 'ts-log';
import { HubConnection } from '@microsoft/signalr';

type Func<T> = () => T;
type AsyncProvider<T> = Func<Promise<T>>;
type AsyncAction<T> = (arg: T) => Promise<void>;
type HeaderProvider<T extends Headers = Headers> = AsyncProvider<T>;
type Headers = {
    [key: string]: unknown;
};

interface DbItem {
    id: string;
    created: string;
    updated: string;
}

interface ApiToken extends DbItem {
    userId: string;
    name: string;
    expirationDate?: number;
    lastUsed?: string;
}

interface ApiResponse<T = unknown> {
    success: boolean;
    data?: T;
    errorMessage?: string;
    statusCode?: number;
}

interface TokenGrant {
    accessToken: string;
    refreshToken: string;
    accessTokenExpiration: string;
    refreshTokenExpiration?: string;
}

interface ApiConfig {
    baseUrl?: string;
    accessToken?: string;
    refreshToken?: string;
}

declare class TokenManager extends ApiEndpoint {
    private readonly refreshCallback?;
    private accessToken?;
    private refreshToken?;
    private accessTokenExpiration?;
    private refreshTokenExpiration?;
    private tokenFetchPromise?;
    constructor(config: ApiConfig, refreshCallback?: AsyncAction<TokenGrant> | undefined, log?: Logger, headerProvider?: HeaderProvider);
    protected endpoint(): string;
    getAccessToken(source?: string): Promise<string | undefined>;
    private fetchToken;
}

declare abstract class ApiEndpoint {
    readonly tokenManager: TokenManager;
    protected readonly log?: Logger | undefined;
    private readonly headerProvider?;
    readonly baseUrl: string;
    protected constructor(baseUrl: string | undefined, tokenManager: TokenManager, log?: Logger | undefined, headerProvider?: HeaderProvider | undefined);
    protected abstract endpoint(): string;
    protected endpointUrl(): string;
    private headersForRequest;
    protected getRequest<T = unknown>(endpoint: string, queryParams?: {
        [key: string]: unknown;
    }, noAuthentication?: boolean): Promise<ApiResponse<T>>;
    protected postRequest<T = unknown>(endpoint: string, data?: unknown, noAuthentication?: boolean): Promise<ApiResponse<T>>;
    protected putRequest<T = unknown>(endpoint: string, data?: unknown, noAuthentication?: boolean): Promise<ApiResponse<T>>;
    protected patchRequest<T = unknown>(endpoint: string, data?: unknown, noAuthentication?: boolean): Promise<ApiResponse<T>>;
    protected deleteRequest(endpoint: string, queryParams?: {
        [key: string]: unknown;
    }, noAuthentication?: boolean): Promise<ApiResponse>;
    private makeRequestWithBody;
    private makeRequestWithoutBody;
    private buildUrl;
    private makeRequest;
}

interface CreateApiTokenRequest {
    name: string;
    expirationDate?: Date;
}

interface SignOutRequest {
    refreshToken: string;
}

declare class AuthEndpoint extends ApiEndpoint {
    constructor(baseUrl: string | undefined, tokenManager: TokenManager, log?: Logger, headerProvider?: HeaderProvider);
    protected endpoint(): string;
    signOut(oldToken: SignOutRequest): Promise<ApiResponse>;
    getApiTokens(): Promise<ApiResponse<ApiToken[]>>;
    createApiToken(newToken: CreateApiTokenRequest): Promise<ApiResponse<string>>;
    deleteApiToken(id: string): Promise<ApiResponse>;
}

interface ChatMessage extends DbItem {
    emergencyId: string;
    senderId: string;
    messageSentTimestamp: number;
    contents: string;
}

interface PaginatedResponse<T = unknown> {
    data: T[];
    paginationToken?: string;
}

interface ChatMessageRequest {
    emergencyId: string;
    contents: string;
}

declare class ChatMessageEndpoint extends ApiEndpoint {
    constructor(baseUrl: string | undefined, tokenManager: TokenManager, log?: Logger, headerProvider?: HeaderProvider);
    protected endpoint(): string;
    getHistory(emergencyId: string, limit: number, paginationToken?: string): Promise<ApiResponse<PaginatedResponse<ChatMessage>>>;
    sendMessage(message: ChatMessageRequest): Promise<ApiResponse<ChatMessage>>;
}

interface ClientHistory extends DbItem {
    emergencyId: string;
    clientId: string;
    emergencyCreationTimestamp: string;
}

interface EmergencyStats {
    success: number;
    failed: number;
    noContact: number;
    refused: number;
    aborted: number;
    serverError: number;
    canceled: number;
}

interface WritableDbItem extends DbItem {
    updated: string;
}

interface Person extends WritableDbItem {
    discordId: string;
    rsiHandle?: string;
    roles: UserRoles;
    personType: PersonType;
    active: boolean;
    deactivationReason: AccountDeactivationReason;
    clientStats: ClientStats;
    activeEmergency?: string;
    clientPortalPreferences: Record<string, unknown>;
    clientPortalPreferencesBlob?: string;
    redeemedCodes: RedeemedCode[];
}
declare enum UserRoles {
    CLIENT = 1,
    STAFF = 2,
    DEVELOPER = 524288,
    BOT = 1048576
}
declare enum PersonType {
    CLIENT = 0,
    STAFF = 1,
    BOT = 2
}
declare enum AccountDeactivationReason {
    NONE = 0,
    CLIENT_DRIVEN_DELETION = 1,
    TERMINATED = 2,
    BLOCKED = 3
}
interface ClientStats {
    missions: EmergencyStats;
}
interface BlockedStatus {
    blocked: boolean;
}
interface RedeemedCode {
    code: string;
    type: CodeType;
}
declare enum CodeType {
    Unknown = 0,
    CitizenCon2954 = 1
}

declare class ClientEndpoint extends ApiEndpoint {
    constructor(baseUrl: string | undefined, tokenManager: TokenManager, log?: Logger, headerProvider?: HeaderProvider);
    protected endpoint(): string;
    get(): Promise<ApiResponse<Person>>;
    getHistory(limit: number, paginationToken?: string): Promise<ApiResponse<PaginatedResponse<ClientHistory>>>;
    getBlockedStatus(): Promise<ApiResponse<BlockedStatus>>;
    linkClient(rsiHandle: string): Promise<ApiResponse>;
    setSettings(settings: Record<string, unknown>): Promise<ApiResponse<Record<string, unknown>>>;
    setUserSettings(settings: string): Promise<ApiResponse>;
    deactivate(): Promise<ApiResponse>;
}

declare class CodeEndpoint extends ApiEndpoint {
    constructor(baseUrl: string | undefined, tokenManager: TokenManager, log?: Logger, headerProvider?: HeaderProvider);
    protected endpoint(): string;
    redeem(code: string): Promise<ApiResponse>;
}

declare enum CancellationReason {
    NONE = 0,
    OTHER = 1,
    SUCCUMBED_TO_WOUNDS = 2,
    SERVER_ERROR = 3,
    RESPAWNED = 4,
    RESCUED = 5
}

declare enum MissionStatus {
    CREATED = 0,
    RECEIVED = 1,
    IN_PROGRESS = 2,
    SUCCESS = 3,
    FAILED = 4,
    NO_CONTACT = 5,
    CANCELED = 6,
    REFUSED = 7,
    ABORTED = 8,
    SERVER_ERROR = 9
}

declare enum ResponseRating {
    NONE = 0,
    GOOD = 1,
    BAD = 2
}

declare enum Class {
    NONE = 0,
    MEDIC = 1,
    SECURITY = 2,
    PILOT = 3,
    LEAD = 4,
    DISPATCH = 5,
    DISPATCH_LEAD = 6,
    DISPATCH_TRAINEE = 7,
    DISPATCH_OBSERVER = 8,
    QRF = 9,
    LOGISTICS = 10
}

interface TeamMember {
    discordId: string;
    id: string;
    rsiHandle?: string;
    class: Class;
    teamId?: string;
}

interface Team {
    staff: TeamMember[];
    dispatchers: TeamMember[];
    allMembers: TeamMember[];
    maxMembers: number;
}

declare enum ThreatLevel {
    UNKNOWN = 0,
    LOW = 1,
    MEDIUM = 2,
    HIGH = 3
}

interface Emergency extends WritableDbItem {
    system: string;
    subsystem: string;
    tertiaryLocation?: string;
    threatLevel: ThreatLevel;
    remarks?: string;
    clientRsiHandle: string;
    clientDiscordId?: string;
    clientId?: string;
    subscriptionTier: string;
    status: MissionStatus;
    alertMessage?: MessageCache;
    clientMessage?: MessageCache;
    coordinationThread?: MessageCache;
    afterActionReportMessage?: MessageCache;
    interactionMessageId?: string;
    respondingTeam: Team;
    respondingTeams: RespondingTeam[];
    creationTimestamp: number;
    acceptedTimestamp?: number;
    completionTimestamp?: number;
    rating: ResponseRating;
    ratingRemarks?: string;
    test: boolean;
    cancellationReason: CancellationReason;
    refusalReason?: string;
    origin: Origin;
    clientData?: ClientData;
    isComplete: boolean;
    missionName?: string;
    afterActionReport?: AfterActionReport;
    submissionSource: SubmissionSource;
}
interface MessageCache {
    id: string;
    channelId: string;
}
interface ClientData {
    rsiHandle: string;
    rsiProfileLink: string;
    gotClientData: boolean;
    redactedOrgOnProfile: boolean;
    reported: boolean;
}
interface AfterActionReport {
    remarks?: string;
    submitterStaffId: string;
    servicesProvided: MissionServices;
    suspectedTrap: boolean;
    hasBeenEdited: boolean;
    submittedOn: number;
    editHistory: AfterActionReportEdit[];
}
interface AfterActionReportEdit {
    editorStaffId: string;
    editTime: number;
}
declare enum MissionServices {
    NONE = 0,
    PVE = 1,
    PVP = 2,
    REVIVED_HEALED = 4,
    HEALED_IN_SHIP = 8,
    EXTRACT_SAFE_ZONE = 16
}
declare enum Origin {
    UNKNOWN = 0,
    REPORT = 1,
    BEACON = 2,
    EVALUATION = 3
}
declare enum SubmissionSource {
    UNKNOWN = 0,
    API = 1,
    BOT = 2
}
interface RespondingTeam {
    id: string;
    teamName: string;
}

interface CreateEmergencyRequest {
    remarks?: string;
    location: Location;
    threatLevel: ThreatLevel;
}
interface Location {
    system: string;
    subsystem: string;
    tertiaryLocation?: string;
}

interface LocationDetail {
    name: string;
    type: LocationType;
    children: LocationDetail[];
}
declare enum LocationType {
    UNKNOWN = 0,
    SYSTEM = 1,
    PLANET = 2,
    MOON = 3
}

declare enum Level {
    None = 0,
    Tier1Section1 = 101,
    Tier1Section2 = 102,
    Tier1Section3 = 103,
    Tier2Section1 = 201,
    Tier2Section2 = 202,
    Tier2Section3 = 203,
    Tier3Section1 = 301,
    Tier3Section2 = 302,
    Tier3Section3 = 303,
    Tier4Section1 = 401,
    Tier4Section2 = 402,
    Tier4Section3 = 403,
    Tier5Section1 = 501,
    Tier5Section2 = 502,
    Tier5Section3 = 503,
    Tier6Section1 = 601,
    Tier6Section2 = 602,
    Tier6Section3 = 603,
    Tier7Section1 = 701,
    Tier7Section2 = 702,
    Tier7Section3 = 703,
    Tier8Section1 = 801,
    Tier8Section2 = 802,
    Tier8Section3 = 803,
    Tier9Section1 = 901,
    Tier9Section2 = 902,
    Tier9Section3 = 903,
    Tier10Section1 = 1001,
    Tier10Section2 = 1002,
    Tier10Section3 = 1003
}

interface TeamDetailsResponse {
    stats: ResponderDetails[];
    aggregatedSuccessRate: number;
}
interface ResponderDetails {
    id: string;
    level: Level;
    missionSuccessRate: number;
    dispatchSuccessRate: number;
}

declare class EmergencyEndpoint extends ApiEndpoint {
    constructor(baseUrl: string | undefined, tokenManager: TokenManager, log?: Logger, headerProvider?: HeaderProvider);
    protected endpoint(): string;
    getEmergency(id: string): Promise<ApiResponse<Emergency>>;
    getEmergencies(ids: string[]): Promise<ApiResponse<Emergency[]>>;
    createEmergency(newEmergency: CreateEmergencyRequest): Promise<ApiResponse<Emergency>>;
    cancelEmergencyWithReason(id: string, reason: CancellationReason): Promise<ApiResponse>;
    rateServices(id: string, rating: ResponseRating, remarks?: string): Promise<ApiResponse>;
    teamDetails(id: string): Promise<ApiResponse<TeamDetailsResponse>>;
    emergencyLocations(): Promise<ApiResponse<LocationDetail[]>>;
}

interface PublicOrgSettings {
    status: ServiceStatus;
    emergenciesEnabled: boolean;
    messageOfTheDay?: MessageOfTheDay;
}
interface MessageOfTheDay {
    message: string;
    dateRange?: DateRange;
}
interface DateRange {
    startDate: string;
    endDate: string;
}
declare enum ServiceStatus {
    UNKNOWN = 0,
    HEALTHY = 1,
    SLIGHTLY_DEGRADED = 2,
    HEAVILY_DEGRADED = 3,
    OFFLINE = 4
}

declare class OrgSettingsEndpoint extends ApiEndpoint {
    constructor(baseUrl: string | undefined, tokenManager: TokenManager, log?: Logger, headerProvider?: HeaderProvider);
    protected endpoint(): string;
    getPublicSettings(): Promise<ApiResponse<PublicOrgSettings>>;
}

interface MedalInformation {
    level: Level;
    successfulMissions: number;
}

declare class StaffEndpoint extends ApiEndpoint {
    constructor(baseUrl: string | undefined, tokenManager: TokenManager, log?: Logger, headerProvider?: HeaderProvider);
    protected endpoint(): string;
    medalsInformation(): Promise<ApiResponse<MedalInformation[]>>;
}

declare class WebsocketEndpoint extends ApiEndpoint {
    constructor(baseUrl: string | undefined, tokenManager: TokenManager, log?: Logger, headerProvider?: HeaderProvider);
    private websocketManager;
    protected endpoint(): string;
    initialize(): Promise<HubConnection>;
}

interface ApiClient<TEmergency extends EmergencyEndpoint = EmergencyEndpoint, TClient extends ClientEndpoint = ClientEndpoint, TStaff extends StaffEndpoint = StaffEndpoint, TOrgSettings extends OrgSettingsEndpoint = OrgSettingsEndpoint, TChatMessage extends ChatMessageEndpoint = ChatMessageEndpoint, TCode extends CodeEndpoint = CodeEndpoint, TAuth extends AuthEndpoint = AuthEndpoint, TWebsocket extends WebsocketEndpoint = WebsocketEndpoint> {
    emergency: TEmergency;
    client: TClient;
    staff: TStaff;
    orgSettings: TOrgSettings;
    chatMessage: TChatMessage;
    code: TCode;
    auth: TAuth;
    websocket: TWebsocket;
}

declare class MedrunnerApiClient<TEmergency extends EmergencyEndpoint = EmergencyEndpoint, TClient extends ClientEndpoint = ClientEndpoint, TStaff extends StaffEndpoint = StaffEndpoint, TOrgSettings extends OrgSettingsEndpoint = OrgSettingsEndpoint, TChatMessage extends ChatMessageEndpoint = ChatMessageEndpoint, TCode extends CodeEndpoint = CodeEndpoint, TAuth extends AuthEndpoint = AuthEndpoint, TWebsocket extends WebsocketEndpoint = WebsocketEndpoint> implements ApiClient<TEmergency, TClient, TStaff, TOrgSettings, TChatMessage, TCode, TAuth, TWebsocket> {
    readonly emergency: TEmergency;
    readonly client: TClient;
    readonly staff: TStaff;
    readonly orgSettings: TOrgSettings;
    readonly chatMessage: TChatMessage;
    readonly code: TCode;
    readonly auth: TAuth;
    readonly websocket: TWebsocket;
    protected constructor(emergency: TEmergency, client: TClient, staff: TStaff, orgSettings: TOrgSettings, chatMessage: TChatMessage, code: TCode, auth: TAuth, websocket: TWebsocket);
    static buildClient(config: ApiConfig, refreshCallback?: AsyncAction<TokenGrant>, log?: Logger): MedrunnerApiClient;
}

export { AccountDeactivationReason, type AfterActionReport, type AfterActionReportEdit, type ApiClient, type ApiConfig, ApiEndpoint, type ApiResponse, type ApiToken, type AsyncAction, type AsyncProvider, AuthEndpoint, type BlockedStatus, CancellationReason, type ChatMessage, ChatMessageEndpoint, type ChatMessageRequest, Class, type ClientData, ClientEndpoint, type ClientHistory, type ClientStats, CodeEndpoint, CodeType, type CreateEmergencyRequest, type DateRange, type DbItem, type Emergency, EmergencyEndpoint, type EmergencyStats, type Func, type HeaderProvider, type Headers, Level, type Location, type LocationDetail, LocationType, type MedalInformation, MedrunnerApiClient, type MessageCache, type MessageOfTheDay, MissionServices, MissionStatus, OrgSettingsEndpoint, Origin, type PaginatedResponse, type Person, PersonType, type PublicOrgSettings, type RedeemedCode, type ResponderDetails, type RespondingTeam, ResponseRating, ServiceStatus, StaffEndpoint, SubmissionSource, type Team, type TeamDetailsResponse, type TeamMember, ThreatLevel, type TokenGrant, TokenManager, UserRoles, WebsocketEndpoint, type WritableDbItem };
